"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[18739],{21315:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=t(74848),r=t(28453);const a={title:"Seata TCC Module Source Code Analysis",author:"runze.zhao",keywords:["Seata","distributed transaction"],date:"2019/12/25"},o=void 0,i={permalink:"/seata.github.io/blog/seata-analysis-tcc-modular",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-analysis-tcc-modular.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-analysis-tcc-modular.md",title:"Seata TCC Module Source Code Analysis",description:"\u4e00. Introduction",date:"2019-12-25T00:00:00.000Z",formattedDate:"December 25, 2019",tags:[],readingTime:7.965,hasTruncateMarker:!1,authors:[{name:"runze.zhao"}],frontMatter:{title:"Seata TCC Module Source Code Analysis",author:"runze.zhao",keywords:["Seata","distributed transaction"],date:"2019/12/25"},unlisted:!1,prevItem:{title:"Source Code Analysis of Seata-XID Propagation in Dubbo",permalink:"/seata.github.io/blog/seata-analysis-dubbo-transmit-xid"},nextItem:{title:"Seata Community Meetup\xb7Hangzhou Station",permalink:"/seata.github.io/blog/seata-community-meetup-hangzhou-ready"}},c={authorsImageUrls:[void 0]},l=[{value:"\u4e00. Introduction",id:"\u4e00-introduction",level:2},{value:"\u4e8c. Introduction to TCC Mode",id:"\u4e8c-introduction-to-tcc-mode",level:2},{value:"Three. Remoting package analysis",id:"three-remoting-package-analysis",level:2},{value:"Three. TCC Resource Manager",id:"three-tcc-resource-manager",level:2},{value:"Four. Transaction Processing in TCC Mode",id:"four-transaction-processing-in-tcc-mode",level:2},{value:"Five. Summary",id:"five-summary",level:2},{value:"Related",id:"related",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"\u4e00-introduction",children:"\u4e00. Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["In the analysis of the Spring module, it is noted that Seata's Spring module handles beans involved in distributed transactions. Upon project startup, when the ",(0,s.jsx)(n.code,{children:"GlobalTransactionalScanner"})," detects references to TCC services (i.e., TCC transaction participants), it dynamically proxies them by weaving in the implementation class of ",(0,s.jsx)(n.code,{children:"MethodInterceptor"})," under the TCC mode. The initiator of the TCC transaction still uses the ",(0,s.jsx)(n.code,{children:"@GlobalTransactional"})," annotation to initiate it, and a generic implementation class of ",(0,s.jsx)(n.code,{children:"MethodInterceptor"})," is woven in."]}),"\n",(0,s.jsxs)(n.p,{children:["The implementation class of ",(0,s.jsx)(n.code,{children:"MethodInterceptor"})," under the TCC mode is referred to as ",(0,s.jsx)(n.code,{children:"TccActionInterceptor"})," (in the Spring module). This class invokes ",(0,s.jsx)(n.code,{children:"ActionInterceptorHandler"})," (in the TCC module) to handle the transaction process under the TCC mode."]}),"\n",(0,s.jsx)(n.p,{children:"The primary functions of TCC dynamic proxy are: generating the TCC runtime context, propagating business parameters, and registering branch transaction records."}),"\n",(0,s.jsx)(n.h2,{id:"\u4e8c-introduction-to-tcc-mode",children:"\u4e8c. Introduction to TCC Mode"}),"\n",(0,s.jsx)(n.p,{children:"In the Two-Phase Commit (2PC) protocol, the transaction manager coordinates resource management in two phases. The resource manager provides three operations: the prepare operation in the first phase, and the commit operation and rollback operation in the second phase."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public interface TccAction {\n\n    @TwoPhaseBusinessAction(name = "tccActionForTest" , commitMethod = "commit", rollbackMethod = "rollback")\n    public boolean prepare(BusinessActionContext actionContext,\n                           @BusinessActionContextParameter(paramName = "a") int a,\n                           @BusinessActionContextParameter(paramName = "b", index = 0) List b,\n                           @BusinessActionContextParameter(isParamInProperty = true) TccParam tccParam);\n\n    public boolean commit(BusinessActionContext actionContext);\n    \n    public boolean rollback(BusinessActionContext actionContext);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This is a participant instance in TCC. Participants need to implement three methods, where the first parameter must be BusinessActionContext, and the return type of the methods is fixed. These methods are exposed as microservices to be invoked by the transaction manager."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"prepare: Checks and reserves resources. For example, deducting the account balance and increasing the same frozen balance."}),"\n",(0,s.jsx)(n.li,{children:"commit: Uses the reserved resources to complete the actual business operation. For example, reducing the frozen balance to complete the fund deduction business."}),"\n",(0,s.jsx)(n.li,{children:"cancel: Releases the reserved resources. For example, adding back the frozen balance to the account balance."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The BusinessActionContext encapsulates the context environment of the current transaction: xid, branchId, actionName, and parameters annotated with @BusinessActionContextParam."}),"\n",(0,s.jsx)(n.p,{children:"There are several points to note in participant business:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure business idempotence, supporting duplicate submission and rollback of the same transaction."}),"\n",(0,s.jsx)(n.li,{children:"Prevent hanging, i.e., the rollback of the second phase occurs before the try phase."}),"\n",(0,s.jsx)(n.li,{children:"Relax consistency protocols, eventually consistent, so it is read-after-write."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"three-remoting-package-analysis",children:"Three. Remoting package analysis"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://img-blog.csdnimg.cn/20191124211806237.png?",alt:"Remoting Package Analysis"})}),"\n",(0,s.jsx)(n.p,{children:"All classes in the package serve DefaultRemotingParser. Dubbo, LocalTCC, and SofaRpc are responsible for parsing classes under their respective RPC protocols."}),"\n",(0,s.jsx)(n.p,{children:"Main methods of DefaultRemotingParser:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Determine if the bean is a remoting bean, code:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"    @Override\n    public boolean isRemoting(Object bean, String beanName) throws FrameworkException {\n        //\u5224\u65ad\u662f\u5426\u662f\u670d\u52a1\u8c03\u7528\u65b9\u6216\u8005\u662f\u5426\u662f\u670d\u52a1\u63d0\u4f9b\u65b9\n        return isReference(bean, beanName) || isService(bean, beanName);\n    }\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Remote bean parsing, parses rpc classes into RemotingDesc."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Override\n    public boolean isRemoting(Object bean, String beanName) throws FrameworkException {\n        //\u5224\u65ad\u662f\u5426\u662f\u670d\u52a1\u8c03\u7528\u65b9\u6216\u8005\u662f\u5426\u662f\u670d\u52a1\u63d0\u4f9b\u65b9\n        return isReference(bean, beanName) || isService(bean, beanName);\n    }\n"})}),"\n",(0,s.jsx)(n.p,{children:"Utilize allRemotingParsers to parse remote beans. allRemotingParsers is dynamically loaded in initRemotingParser() by calling EnhancedServiceLoader.loadAll(RemotingParser.class), which implements the SPI loading mechanism for loading subclasses of RemotingParser."}),"\n",(0,s.jsx)(n.p,{children:"For extension purposes, such as implementing a parser for feign remote calls, simply write the relevant implementation classes of RemotingParser in the SPI configuration. This approach offers great extensibility."}),"\n",(0,s.jsx)(n.p,{children:"RemotingDesc contains specific information about remote beans required for the transaction process, such as targetBean, interfaceClass, interfaceClassName, protocol, isReference, and so on."}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"TCC Resource Registration"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public RemotingDesc parserRemotingServiceInfo(Object bean, String beanName) {\n        RemotingDesc remotingBeanDesc = getServiceDesc(bean, beanName);\n        if (remotingBeanDesc == null) {\n            return null;\n        }\n        remotingServiceMap.put(beanName, remotingBeanDesc);\n\n        Class<?> interfaceClass = remotingBeanDesc.getInterfaceClass();\n        Method[] methods = interfaceClass.getMethods();\n        if (isService(bean, beanName)) {\n            try {\n                //service bean, registry resource\n                Object targetBean = remotingBeanDesc.getTargetBean();\n                for (Method m : methods) {\n                    TwoPhaseBusinessAction twoPhaseBusinessAction = m.getAnnotation(TwoPhaseBusinessAction.class);\n                    if (twoPhaseBusinessAction != null) {\n                        TCCResource tccResource = new TCCResource();\n                        tccResource.setActionName(twoPhaseBusinessAction.name());\n                        tccResource.setTargetBean(targetBean);\n                        tccResource.setPrepareMethod(m);\n                        tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());\n                        tccResource.setCommitMethod(ReflectionUtil\n                            .getMethod(interfaceClass, twoPhaseBusinessAction.commitMethod(),\n                                new Class[] {BusinessActionContext.class}));\n                        tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());\n                        tccResource.setRollbackMethod(ReflectionUtil\n                            .getMethod(interfaceClass, twoPhaseBusinessAction.rollbackMethod(),\n                                new Class[] {BusinessActionContext.class}));\n                        //registry tcc resource\n                        DefaultResourceManager.get().registerResource(tccResource);\n                    }\n                }\n            } catch (Throwable t) {\n                throw new FrameworkException(t, "parser remoting service error");\n            }\n        }\n        if (isReference(bean, beanName)) {\n            //reference bean, TCC proxy\n            remotingBeanDesc.setReference(true);\n        }\n        return remotingBeanDesc;\n    }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Firstly, determine if it is a transaction participant. If so, obtain the interfaceClass from RemotingDesc, iterate through the methods in the interface, and check if there is a @TwoParserBusinessAction annotation on the method. If found, encapsulate the parameters into TCCResource and register the TCC resource through DefaultResourceManager."}),"\n",(0,s.jsx)(n.p,{children:"Here, DefaultResourceManager will search for the corresponding resource manager based on the BranchType of the Resource. The resource management class under the TCC mode is in the tcc module."}),"\n",(0,s.jsx)(n.p,{children:"This RPC parsing class is mainly provided for use by the spring module. parserRemotingServiceInfo() is encapsulated into the TCCBeanParserUtils utility class in the spring module. During project startup, the GlobalTransactionScanner in the spring module parses TCC beans through the utility class. TCCBeanParserUtils calls TCCResourceManager to register resources. If it is a global transaction service provider, it will weave in the TccActionInterceptor proxy. These processes are functionalities of the spring module, where the tcc module provides functional classes for use by the spring module."}),"\n",(0,s.jsx)(n.h2,{id:"three-tcc-resource-manager",children:"Three. TCC Resource Manager"}),"\n",(0,s.jsx)(n.p,{children:"TCCResourceManager is responsible for managing the registration, branching, committing, and rolling back of resources under the TCC mode."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"During project startup, when the GlobalTransactionScanner in the spring module detects that a bean is a tcc bean, it caches resources locally and registers them with the server:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"    @Override\n    public void registerResource(Resource resource) {\n        TCCResource tccResource = (TCCResource)resource;\n        tccResourceCache.put(tccResource.getResourceId(), tccResource);\n        super.registerResource(tccResource);\n    }\n"})}),"\n",(0,s.jsx)(n.p,{children:"The logic for communicating with the server is encapsulated in the parent class AbstractResourceManager. Here, TCCResource is cached based on resourceId. When registering resources in the parent class AbstractResourceManager, resourceGroupId + actionName is used, where actionName is the name specified in the @TwoParseBusinessAction annotation, and resourceGroupId defaults to DEFAULT."}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Transaction branch registration is handled in the rm-datasource package under AbstractResourceManager. During registration, the parameter lockKeys is null, which differs from the transaction branch registration under the AT mode."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Committing or rolling back branches:"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'    @Override\n    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n                                     String applicationData) throws TransactionException {\n        TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);\n        if (tccResource == null) {\n            throw new ShouldNeverHappenException("TCC resource is not exist, resourceId:" + resourceId);\n        }\n        Object targetTCCBean = tccResource.getTargetBean();\n        Method commitMethod = tccResource.getCommitMethod();\n        if (targetTCCBean == null || commitMethod == null) {\n            throw new ShouldNeverHappenException("TCC resource is not available, resourceId:" + resourceId);\n        }\n        try {\n            boolean result = false;\n            //BusinessActionContext\n            BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,\n                applicationData);\n            Object ret = commitMethod.invoke(targetTCCBean, businessActionContext);\n            if (ret != null) {\n                if (ret instanceof TwoPhaseResult) {\n                    result = ((TwoPhaseResult)ret).isSuccess();\n                } else {\n                    result = (boolean)ret;\n                }\n            }\n            return result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;\n        } catch (Throwable t) {\n            LOGGER.error(msg, t);\n            throw new FrameworkException(t, msg);\n        }\n    }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Restore the business context using parameters xid, branchId, resourceId, and applicationData."}),"\n",(0,s.jsx)(n.p,{children:"Execute the commit method through reflection based on the retrieved context and return the execution result. The rollback method follows a similar approach."}),"\n",(0,s.jsx)(n.p,{children:"Here, branchCommit() and branchRollback() are provided for AbstractRMHandler, an abstract class for resource processing in the rm module. This handler is a further implementation class of the template method defined in the core module. Unlike registerResource(), which actively registers resources during spring scanning."}),"\n",(0,s.jsx)(n.h2,{id:"four-transaction-processing-in-tcc-mode",children:"Four. Transaction Processing in TCC Mode"}),"\n",(0,s.jsx)(n.p,{children:"The invoke() method of TccActionInterceptor in the spring module is executed when the proxied rpc bean is called. This method first retrieves the global transaction xid passed by the rpc interceptor, and then the transaction process of global transaction participants under TCC mode is still handed over to the ActionInterceptorHandler in the tcc module."}),"\n",(0,s.jsx)(n.p,{children:"In other words, transaction participants are proxied during project startup. The actual business methods are executed through callbacks in ActionInterceptorHandler."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"    public Map<String, Object> proceed(Method method, Object[] arguments, String xid, TwoPhaseBusinessAction businessAction,\n                                       Callback<Object> targetCallback) throws Throwable {\n        Map<String, Object> ret = new HashMap<String, Object>(4);\n\n        //TCC name\n        String actionName = businessAction.name();\n        BusinessActionContext actionContext = new BusinessActionContext();\n        actionContext.setXid(xid);\n        //set action anme\n        actionContext.setActionName(actionName);\n\n        //Creating Branch Record\n        String branchId = doTccActionLogStore(method, arguments, businessAction, actionContext);\n        actionContext.setBranchId(branchId);\n\n        //set the parameter whose type is BusinessActionContext\n        Class<?>[] types = method.getParameterTypes();\n        int argIndex = 0;\n        for (Class<?> cls : types) {\n            if (cls.getName().equals(BusinessActionContext.class.getName())) {\n                arguments[argIndex] = actionContext;\n                break;\n            }\n            argIndex++;\n        }\n        //the final parameters of the try method\n        ret.put(Constants.TCC_METHOD_ARGUMENTS, arguments);\n        //the final result\n        ret.put(Constants.TCC_METHOD_RESULT, targetCallback.execute());\n        return ret;\n    }\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here are two important operations:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"In the doTccActionLogStore() method, two crucial methods are called:"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fetchActionRequestContext(method, arguments): This method retrieves parameters annotated with @BusinessActionContextParam and inserts them into BusinessActionComtext along with transaction-related parameters in the init method below."}),"\n",(0,s.jsx)(n.li,{children:"DefaultResourceManager.get().branchRegister(BranchType.TCC, actionName, null, xid, applicationContextStr, null): This method performs the registration of transaction branches for transaction participants under TCC mode."}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Callback execution of targetCallback.execute(), which executes the specific business logic of the proxied bean, i.e., the prepare() method."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"five-summary",children:"Five. Summary"}),"\n",(0,s.jsx)(n.p,{children:"The tcc module primarily provides the following functionalities:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Defines annotations for two-phase protocols, providing attributes needed for transaction processes under TCC mode."}),"\n",(0,s.jsx)(n.li,{children:"Provides implementations of ParserRemoting for parsing remoting beans of different RPC frameworks, to be invoked by the spring module."}),"\n",(0,s.jsx)(n.li,{children:"Provides the TCC ResourceManager for resource registration, transaction branch registration, submission, and rollback under TCC mode."}),"\n",(0,s.jsx)(n.li,{children:"Provides classes for handling transaction processes under TCC mode, allowing MethodInterceptor proxy classes to delegate the execution of specific mode transaction processes to the tcc module."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,s.jsxs)(n.p,{children:["Author: Zhao Runze, ",(0,s.jsx)(n.a,{href:"https://blog.csdn.net/qq_37804737/category_9530078.html",children:"Series Link"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);